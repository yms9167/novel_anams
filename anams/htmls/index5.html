<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>데이터 패킷 전송을 위한 최단 경로 알고리즘 보고서</title>
    <!-- Tailwind CSS CDN 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Inter 폰트 설정 (Tailwind 기본 설정에 포함되어 있지만 명시적으로 설정) */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        /* 핵심 카드 요소의 그림자 및 둥근 모서리 */
        .report-card {
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            transition: transform 0.3s ease;
        }
        .report-card:hover {
            transform: translateY(-2px);
        }
    </style>
</head>
<body class="p-4 sm:p-8 lg:p-12">

    <div class="max-w-4xl mx-auto">
        
        <!-- 제목 섹션 -->
        <header class="text-center mb-10 p-6 bg-white rounded-xl shadow-lg">
            <h1 class="text-3xl sm:text-4xl font-extrabold text-indigo-700 mb-2">
                데이터 패킷 전송을 위한 최단 경로 알고리즘 보고서
            </h1>
            <p class="text-lg text-gray-500">
                네트워크 통신 효율성 극대화를 위한 라우팅 분석
            </p>
        </header>

        <!-- 본문 내용 -->
        <main class="space-y-10">
            
            <!-- 1. 데이터 패킷의 뜻 -->
            <section class="report-card bg-white p-6 sm:p-8">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 flex items-center">
                    <span class="mr-3 text-indigo-500 text-3xl">1</span> 데이터 패킷이란?
                </h2>
                <div class="border-l-4 border-indigo-400 pl-4">
                    <p class="text-gray-700 leading-relaxed mb-3">
                        데이터 패킷(Data Packet)은 컴퓨터 네트워크를 통해 전송되는 정보의 기본 단위입니다. 대용량의 데이터가 한 번에 전송되면 네트워크 효율성이 떨어지기 때문에, 데이터를 송신하기 전에 작고 관리하기 쉬운 조각들로 분할하는데, 이 조각 하나하나를 패킷이라고 부릅니다.
                    </p>
                    <p class="text-gray-700 leading-relaxed">
                        패킷은 크게 두 부분으로 구성됩니다.
                        <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
                            <li class="text-sm text-gray-600"><strong class="font-semibold">헤더(Header):</strong> 출발지 및 목적지 주소, 패킷의 순서 번호, 오류 제어 정보 등 라우팅에 필요한 제어 정보가 포함됩니다.</li>
                            <li class="text-sm text-gray-600"><strong class="font-semibold">페이로드(Payload):</strong> 실제로 전송하고자 하는 원본 데이터가 담겨 있습니다.</li>
                        </ul>
                    </p>
                </div>
            </section>

            <!-- 2. 데이터 패킷이 독립적으로 이동하는 이유 (패킷 교환) -->
            <section class="report-card bg-white p-6 sm:p-8">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 flex items-center">
                    <span class="mr-3 text-indigo-500 text-3xl">2</span> 데이터 패킷이 독립적으로 이동하는 이유
                </h2>
                <div class="border-l-4 border-indigo-400 pl-4">
                    <p class="text-gray-700 leading-relaxed mb-3">
                        데이터 패킷이 네트워크에서 독립적으로 이동하는 원리는 <strong class="text-indigo-600 font-semibold">패킷 교환(Packet Switching)</strong> 방식에 기반합니다. 이는 전통적인 회선 교환(Circuit Switching) 방식과 대비되는 개념으로, 현대 인터넷 통신의 핵심 기술입니다.
                    </p>
                    <p class="text-gray-700 leading-relaxed mb-3">
                        회선 교환은 통신을 시작하기 전에 출발지부터 목적지까지 전용 통신 경로를 미리 설정하고 이 경로를 독점적으로 사용합니다. 반면, 패킷 교환에서는 각 패킷이 네트워크 노드(라우터)에 도착할 때마다 헤더에 포함된 목적지 정보를 바탕으로 다음 경로를 독립적으로 결정합니다.
                    </p>
                    <p class="text-gray-700 leading-relaxed">
                        이러한 독립적인 이동 방식이 필요한 주요 이유는 다음과 같습니다.
                        <ul class="list-disc list-inside ml-4 mt-2 space-y-1">
                            <li class="text-sm text-gray-600"><strong class="font-semibold">네트워크 자원 공유 및 효율성:</strong> 하나의 통신 경로를 여러 사용자의 패킷이 번갈아 사용함으로써, 유휴 시간 없이 네트워크 대역폭을 최대한 활용하여 효율성을 극대화합니다.</li>
                            <li class="text-sm text-gray-600"><strong class="font-semibold">유연성과 내결함성(Fault Tolerance):</strong> 특정 경로에 장애가 발생하더라도, 후속 패킷들은 다른 정상적인 경로를 선택하여 목적지에 도달할 수 있습니다. 이는 네트워크의 안정성을 높입니다.</li>
                            <li class="text-sm text-gray-600"><strong class="font-semibold">비동기 통신 지원:</strong> 패킷 전송이 실시간으로 이루어지지 않아도 되며, 패킷이 도착하는 순서가 달라도 재조합 과정을 통해 데이터를 복원할 수 있습니다.</li>
                        </ul>
                    </p>
                </div>
            </section>
            
            <!-- 3. 주로 사용하는 최단 경로 알고리즘 -->
            <section class="report-card bg-white p-6 sm:p-8">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 flex items-center">
                    <span class="mr-3 text-indigo-500 text-3xl">3</span> 주요 최단 경로 알고리즘
                </h2>
                <p class="text-gray-700 leading-relaxed mb-6">
                    네트워크에서 라우터는 실시간으로 최적의 경로를 결정해야 합니다. 여기서 '최단 경로'는 물리적 거리뿐만 아니라 지연 시간(Latency), 대역폭(Bandwidth), 비용 등의 요소를 종합한 '최소 비용 경로'를 의미합니다. 다음은 주로 사용되는 알고리즘입니다.
                </p>

                <!-- 다익스트라 알고리즘 -->
                <div class="bg-indigo-50 p-4 rounded-lg mb-4 border border-indigo-200">
                    <h3 class="text-xl font-semibold text-indigo-700 mb-2">
                        다익스트라(Dijkstra's) 알고리즘
                    </h3>
                    <div class="border-l-2 border-indigo-500 pl-3">
                        <p class="text-sm text-gray-700 mb-2">
                            <strong class="font-medium">원리:</strong> 단일 출발지(Single-Source)에서 네트워크의 모든 다른 노드까지의 최단 경로를 찾는 알고리즘입니다. 그리디(Greedy) 방식을 사용하여, 현재까지 알려진 최단 거리가 가장 짧은 노드를 선택하고 그 노드를 경유했을 때의 거리를 갱신합니다.
                        </p>
                        <p class="text-sm text-gray-700 mb-2">
                            <strong class="font-medium">핵심 특징:</strong> <span class="text-red-600 font-bold">음수 가중치(Negative Edge Weight)를 허용하지 않습니다.</span> 대부분의 네트워크 환경(예: OSPF 라우팅 프로토콜)에서 링크 비용은 양수이므로 가장 널리 사용됩니다.
                        </p>
                    </div>
                </div>

                <!-- 벨만-포드 알고리즘 -->
                <div class="bg-indigo-50 p-4 rounded-lg border border-indigo-200">
                    <h3 class="text-xl font-semibold text-indigo-700 mb-2">
                        벨만-포드(Bellman-Ford) 알고리즘
                    </h3>
                    <div class="border-l-2 border-indigo-500 pl-3">
                        <p class="text-sm text-gray-700 mb-2">
                            <strong class="font-medium">원리:</strong> 다익스트라와 마찬가지로 단일 출발지 최단 경로를 찾지만, <span class="text-green-600 font-bold">음수 가중치를 포함하는 그래프에서도 작동합니다.</span> 모든 간선을 V-1번 반복하여 최단 거리를 갱신하는 동적 프로그래밍 기반 알고리즘입니다. (V는 노드의 개수)
                        </p>
                        <p class="text-sm text-gray-700">
                            <strong class="font-medium">핵심 특징:</strong> 다익스트라보다 느리지만, 음수 가중치 처리가 가능하며, 최단 경로를 찾을 수 없는 <strong class="font-bold">음수 사이클(Negative Cycle)의 존재 여부를 감지</strong>할 수 있습니다. 이는 일부 특수한 네트워크 환경이나 분산 라우팅 프로토콜(예: RIP)의 기초 개념으로 사용됩니다.
                        </p>
                    </div>
                </div>
            </section>
            
        </main>

        <!-- 푸터 섹션 -->
        <footer class="mt-10 pt-6 border-t border-gray-300 text-center text-gray-500 text-sm">
            <p>본 보고서는 데이터 통신 및 네트워크 라우팅의 기초 개념을 포함하고 있습니다.</p>
        </footer>

    </div>

</body>
</html>